作者： Martin Kleppmann                        
阅读日期：20250811——20250830
学习网站：http://ddia.vonng.com/

# 目录

第一部分：数据系统基础——设计数据密集型应用所赖的基本思想
1. 数据系统架构中的权衡 
2. 定义非功能性需求 
3. 数据模型与查询语言 
4. 存储与检索 
5. 编码与演化
第二部分：分布式数据——存储在一台机器上的数据转向讨论分布在多台机器上的数据
6. 复制 
7. 分片 
8. 事务 
9. 分布式系统的麻烦 
10.  一致性与共识 
第三部分：派生数据——从其他数据集派生出一些数据集的系统。
11. 批处理 
12. 流处理 
13. 数据系统的未来 

# 序言

**数据密集型应用（data-intensive applications）** 正在通过使用这些技术进步来推动可能性的边界。一个应用被称为 **数据密集型** 的，如果 **数据是其主要挑战**（数据量，数据复杂度或数据变化速度）—— 与之相对的是 **计算密集型**，即处理器速度是其瓶颈。

# 第一部分：数据系统基础

## 1、数据系统架构中的权衡 

如果数据管理是开发应用程序的主要挑战之一，我们就称应用程序为 **数据密集型（data-intensive）** 的，关心诸如**存储和处理大量数据、管理数据变更、在面对故障和并发时确保一致性，以及确保服务高可用**等问题。一般需要通过**数据库、缓存、索引、流批处理**来构建。

### 分析型与事务型系统

三类人：
- **后端工程师**：构建处理读取和更新数据请求的服务；这些服务通常直接或间接地通过其他服务为外部用户提供服务
- **业务分析师**：生成关于组织活动的报告，以帮助管理层做出更好的决策
- **数据科学家**：在数据中寻找新的见解，或创建由数据分析和机器学习/AI 支持的面向用户的产品功能

业务分析师和数据科学家两者都执行 **分析**，这意味着他们查看用户和后端服务生成的数据，但他们通常不修改这些数据，这导致了两种类型系统之间的分离：
- **事务型系统** 由后端服务和数据基础设施组成，在这里创建数据，例如通过服务外部用户。在这里，应用程序代码基于用户执行的操作读取和修改其数据库中的数据。
- **分析型系统** 服务于业务分析师和数据科学家的需求。它们包含来自事务型系统的只读数据副本，并针对分析所需的数据处理类型进行了优化。

随着这些系统的成熟，出现了两个新的专业角色：**数据工程师** 和 **分析工程师**。
- **数据工程师**是知道如何集成事务型系统和分析型系统的人，并更广泛地负责组织的数据基础设施
- **分析工程师**对数据进行建模和转换，使其对组织中的业务分析师和数据科学家更有用

#### 事务处理与分析的特征

- **OLTP**：事务型系统通常通过某个键查找少量记录（这称为 **点查询**）。基于用户的输入插入、更新或删除记录。因为这些应用程序是交互式的，这种访问模式被称为 **联机事务处理**（OLTP）
- **OLAP**：分析具有非常不同的访问模式。通常，分析查询会扫描大量记录，并计算聚合统计信息（如计数、求和或平均值），而不是将单个记录返回给用户，被称为 **联机分析处理**（OLAP）

|属性|事务型系统（OLTP）|分析型系统（OLAP）|
|---|---|---|
|主要读取模式|点查询（通过键获取单个记录）|对大量记录进行聚合|
|主要写入模式|创建、更新和删除单个记录|批量导入（ETL）或事件流|
|人类用户示例|Web/移动应用程序的最终用户|内部分析师，用于决策支持|
|机器使用示例|检查操作是否被授权|检测欺诈/滥用模式|
|查询类型|固定的查询集，由应用程序预定义|分析师可以进行任意查询|
|数据代表|数据的最新状态（当前时间点）|随时间发生的事件历史|
|数据集大小|GB 到 TB|TB 到 PB|
#### 数据仓库

90 年代初，公司倾向于停止使用其 OLTP 系统进行分析目的，而是在单独的数据库系统上运行分析。这个单独的数据库被称为 **数据仓库**。有以下几个原因：
- 数据孤岛问题
- 查询模式和数据布局不太合适
- 分析查询相当昂贵

数据仓库包含公司中所有各种 OLTP 系统中数据的只读副本。数据从 OLTP 数据库中提取（使用定期数据转储或连续更新流），转换为分析友好的模式，清理，然后加载到数据仓库中。这种将数据导入数据仓库的过程称为 **提取-转换-加载**（ETL）
![[file-20250811204322471.png]]
一些数据库系统提供 **混合事务/分析处理**（HTAP），旨在在单个系统中启用 OLTP 和分析，而无需从一个系统 ETL 到另一个系统。**HTAP 不会取代数据仓库**。相反，它在同一应用程序需要既执行扫描大量行的分析查询，又以低延迟读取和更新单个记录的场景中很有用。

##### 从数据仓库到数据湖

**数据分析师**：使用通过 SQL 查询的 **关系** 数据模型
**数据科学家**：将数据转换为适合训练机器学习模型的形式（特征工程）；使用自然语言处理技术尝试从中提取结构化信息。


数据科学家不喜欢在数据仓库等关系数据库中工作，更喜欢使用 Python 数据分析库（如 pandas 和 scikit-learn）、统计分析语言（如 R）和分布式分析框架。

组织面临着以适合数据科学家使用的形式提供数据的需求。通过数据湖解决：

**数据湖**：一个集中的数据存储库，保存任何可能对分析有用的数据副本，通过 ETL 过程从事务型系统获得。与数据仓库的区别在于，数据湖只是包含文件，而不强制任何特定的文件格式或数据模型。数据湖中的文件可能是数据库记录的集合，使用 Avro 或 Parquet 等文件格式编码，但它们同样可以包含文本、图像、视频、传感器读数、稀疏矩阵、特征向量、基因组序列或任何其他类型的数据 [15](http://ddia.vonng.com/ch1/#fn:15)。除了更灵活之外，这通常也比关系数据存储更便宜，因为数据湖可以使用商品化的文件存储，如对象存储

ETL 过程已经泛化为 **数据管道**

从数据湖加载数据到单独的数据仓库之外，还可以直接在数据湖中的文件上运行典型的数据仓库工作负载（SQL 查询和业务分析），以及数据科学/机器学习工作负载。这种架构被称为 **数据湖仓**，它需要一个查询执行引擎和一个元数据（例如，模式管理）层来扩展数据湖的文件存储。
**数据湖仓**：数据湖上的仓，是湖也是仓

##### 超越数据湖

在某些情况下，分析系统的输出被提供给事务型系统（这个过程有时被称为 **反向 ETL**）

例如，在分析系统中训练的机器学习模型可能会部署到生产环境中，以便为最终用户生成推荐，例如"购买了 X 的人也购买了 Y"。这种分析系统的部署输出也被称为 **数据产品**

#### 权威数据源与派生数据

**权威记录系统**：权威记录系统，也称为 权威数据源，保存某些数据的权威或 规范 版本。当新数据进入时，例如作为用户输入，它首先写入这里。每个事实只表示一次。如果另一个系统与权威记录系统之间存在任何差异，那么权威记录系统中的值（根据定义）是正确的。

**派生数据系统**：派生系统中的数据是从另一个系统获取一些现有数据并以某种方式转换或处理它的结果。如果你丢失了派生数据，你可以从原始源重新创建它。一个经典的例子是缓存：如果存在，可以从缓存提供数据，但如果缓存不包含你需要的内容，你可以回退到底层数据库。反规范化值、索引、物化视图、转换的数据表示和在数据集上训练的模型也属于这一类别。

- 分析系统通常是派生数据系统，因为它们是在其他地方创建的数据的消费者。
- 事务型服务可能包含权威记录系统和派生数据系统的混合。

### 云服务与自托管

公认的管理智慧是，作为组织核心竞争力或竞争优势的事物应该在内部完成，而非核心、例行或常见的事物应该留给供应商。
 **自托管** 的现成软件（开源或商业），即自己部署

#### 云服务的利弊

云服务的最大缺点是你无法控制它：
- 功能定制开发
- 服务宕机等恢复
- 出错难以诊断
- 存在数据安全问题

#### 云原生系统架构

从头开始设计为云原生的系统已被证明具有几个优势：在相同硬件上具有更好的性能、从故障中更快恢复、 能够快速扩展计算资源以匹配负载，以及支持更大的数据集

| 类别       | 自托管系统                     | 云原生系统                                                     |
| -------- | ------------------------- | --------------------------------------------------------- |
| 事务型/OLTP | MySQL、PostgreSQL、MongoDB  | AWS Aurora 、Azure SQL DB Hyperscale 、Google Cloud Spanner |
| 分析型/OLAP | Teradata、ClickHouse、Spark | Snowflake、Google BigQuery、Azure Synapse Analytics         |
###### 云服务的分层

- 自托管软件倾向于使用非常通用的计算资源：CPU、RAM、文件系统和 IP 网络。
- 云实例可以更快地配置，并且有更多种类的大小，但除此之外，它们与传统计算机类似

云原生服务的关键思想是不仅使用由操作系统管理的计算资源，还基于较低级别的云服务构建更高级别的服务。例如：
- **对象存储** 服务存储大文件，隐藏了底层物理机器，不必担心任何一台机器上的磁盘空间用完，也不会丢失数据。
- 许多其他服务反过来建立在对象存储和其他云服务之上：例如，Snowflake 是一个基于云的分析数据库（数据仓库），依赖于 S3 进行数据存储

###### 存储和计算的分离

**传统计算**：磁盘存储被认为是持久的，为了容忍单个硬盘的故障，通常使用 RAID（独立磁盘冗余阵列）在连接到同一台机器的几个磁盘上维护数据副本。它对访问文件系统的应用程序是透明的。
**云计算**：云原生系统通常将这些磁盘更多地视为临时缓存，而不是长期存储。如果实例被替换，本地磁盘会不可访问

云服务还提供可以从一个实例分离并附加到另一个实例的虚拟磁盘存储，种虚拟磁盘实际上不是物理磁盘，而是由一组单独的机器提供的云服务，它模拟磁盘的行为。但是对网络很敏感。

云原生服务通常避免使用虚拟磁盘，而是建立在针对特定工作负载优化的专用存储服务之上。对象存储服务（如 S3）设计用于长期存储相当大的文件，大小从数百千字节到几千兆字节不等。数据库中存储的单个行或值通常比这小得多；
**云数据库通常在单独的服务中管理较小的值，并将较大的数据块（包含许多单个值）存储在对象存储中**

云原生系统中，存储（磁盘）和计算（CPU 和 RAM）在某种程度上分离或 **解耦**。

#### 云时代的运维

**运维**：确保服务可靠地交付给用户（包括配置基础设施和部署应用程序），并确保稳定的生产环境（包括监控和诊断可能影响可靠性的任何问题）

从单个机器到服务的重点转移伴随着运维角色的变化。提供可靠服务的高级目标保持不变，但流程和工具已经发展。DevOps/SRE 理念更加强调：自动化、频繁更新等等。

云正在改变运维的角色，但对运维的需求比以往任何时候都大。

### 分布式与单节点系统

涉及多台机器通过网络通信的系统称为 **分布式系统**。参与分布式系统的每个进程称为 **节点**。做分布式有很多原因，如：高可用、可伸缩、低延迟、弹性、可持续性等等

#### 分布式系统的问题

- 网络传输中断、响应时间慢、分布式事务等等

#### 微服务与 Serverless

分布系统的最常见方式是：分为客户端和服务器，并让客户端向服务器发出请求。最常见的是使用 HTTP 进行此通信。

这种构建应用程序的方式传统上被称为 **面向服务架构**（SOA），目前被细化为**微服务** 架构。

微服务架构的特点：服务有一个明确定义的目的；每个服务公开一个可以由客户端通过网络调用的 API，每个服务有一个负责其维护的团队。

带来的复杂性：每个服务都需要用于部署新版本、调整分配的硬件资源以匹配负载、收集日志、监控服务健康状况以及在出现问题时向值班工程师发出警报的基础设施。

#### 云计算与超级计算

云计算不是构建大规模计算系统的唯一方式；另一种选择是 **高性能计算**（HPC），也称为 **超级计算**。HPC 通常有不同的优先级并使用不同的技术：
- HPC 通常有不同的优先级并使用不同的技术。
- 通常运行大型批处理作业，定期将其计算状态检查点到磁盘。
- 通常通过共享内存和远程直接内存访问（RDMA）进行通信，这支持高带宽和低延迟

### 数据系统、法律与社会

**通用数据保护条例**（GDPR）：多欧洲国家居民对其个人数据更大的控制权和法律权利，类似的隐私法规已在世界各地的各个国家和州采用，包括例如加州消费者隐私法（CCPA）。关于 AI 的法规，例如 **欧盟 AI 法案**，对个人数据的使用方式施加了进一步的限制。

## 2. 定义非功能性需求

应用程序的非功能需求，比如应用程序应该快速、可靠、安全、合规，并且易于维护

从一个案例研究开始本章，研究社交网络服务可能如何工作，这将提供性能和可伸缩性的实际案例。

### 案例研究：社交网络首页时间线

社交网络服务：假设用户每天发布 5 亿条帖子，或平均每秒 5,700 条帖子。偶尔，速率可能飙升至每秒 150,000 条帖子。

![[file-20250812104503252.png]]
帖子应该是及时的，所以假设在某人发布帖子后，我们希望他们的粉丝能够在 5 秒内看到它。一种方法是让用户的客户端每 5 秒重复上述查询（这称为 _轮询_）。如果我们假设有 1000 万用户同时在线登录，这意味着每秒运行 200 万次查询。即使增加轮询间隔，这也是很大的负载。

#### 时间线的物化与更新

每次用户发布帖子时，我们查找他们的所有粉丝，并将该帖子插入到每个粉丝的首页时间线中——就像向邮箱投递消息一样。现在当用户登录时，我们可以简单地给他们这个预先计算的首页时间线。此外，要接收时间线上任何新帖子的通知，用户的客户端只需订阅添加到其首页时间线的帖子流。
![[file-20250812104720007.png]]这种预先计算和更新查询结果的过程称为 **物化**，时间线缓存是 _物化视图_ 的一个例子

### 描述性能

考虑两种主要的度量类型：
- **响应时间**：从用户发出请求到收到所请求答案的经过时间。
- **吞吐量**：系统正在处理的每秒请求数，或每秒数据量。

随着服务的吞吐量接近其容量，由于排队，响应时间急剧增加。
![[file-20250812105314815.png]]

就性能指标而言，响应时间通常是用户最关心的，而吞吐量决定了所需的计算资源，因此决定了服务特定工作负载的成本。
如果系统的最大吞吐量可以通过添加计算资源显著增加，则称系统为 _可伸缩的_。

#### 延迟与响应时间

- _响应时间_ 是客户端看到的；它包括系统中任何地方产生的所有延迟。
- _服务时间_ 是服务主动处理用户请求的持续时间。
- _排队延迟_ 可能发生在流程中的几个点：例如，在收到请求后，它可能需要等待直到 CPU 可用才能被处理；如果同一台机器上的其他任务通过出站网络接口发送大量数据，响应数据包可能需要在发送之前进行缓冲。
- _延迟_ 是一个涵盖请求未被主动处理时间的总称，即在此期间它是 _潜在的_。特别是，_网络延迟_ 或 _网络延迟_ 指的是请求和响应在网络中传输所花费的时间。
![[file-20250812110210600.png]]
#### 平均值、中位数与百分位数

因为响应时间因请求而异，我们需要将其视为值的 _分布_，而不是单个数字。
**平均响应时间**：对于估计吞吐量限制很有用
**中位数**：如果你将响应时间列表从最快到最慢排序，那么 _中位数_ 就在中间中位数成为了解用户通常需要等待多长时间的良好指标。中位数也称为 _第 50 百分位_，有时缩写为 _p50_。
**百分位数**：为了弄清异常值有多糟糕，_第 95_、_99_ 和 _99.9_ 百分位数很常见，它们是 95%、99% 或 99.9% 的请求比该特定阈值快的响应时间阈值。

响应时间的高百分位数，也称为 _尾部延迟_，很重要，因为它们直接影响用户的服务体验。

#### 响应时间指标的应用

高百分位数在被多次调用作为服务单个最终用户请求的一部分的后端服务中尤其重要。

百分位数通常用于 _服务级别目标_（SLO）和 _服务级别协议_（SLA），作为定义服务预期性能和可用性的方式

### 可靠性与容错

可靠性：即使出现问题也能继续正确工作。
为了更准确地说明出现问题，我们将区分 故障 和 失效：
- **故障**：故障是指系统的某个特定 _部分_ 停止正确工作：例如，如果单个硬盘驱动器发生故障，或单台机器崩溃，或外部服务（系统所依赖的）发生中断。
- **失效**：失效是指 _整个_ 系统停止向用户提供所需的服务；换句话说，当它不满足服务级别目标（SLO）时。

故障和失效之间的区别可能会令人困惑，因为它们在不同层面上是同一件事。
#### 容错

**容错**：如果系统在发生某些故障时仍继续向用户提供所需的服务，我们称系统为 _容错的_。
**单点故障**：如果系统不能容忍某个部分变得有故障，我们称该部分为 _单点故障_（SPOF），因为该部分的故障会升级导致整个系统的失效。
**故障注入**：在这种容错系统中，通过故意触发故障来 _增加_ 故障率是有意义。通过故意引发故障，你确保容错机制不断得到锻炼和测试，这可以增加你对故障自然发生时将被正确处理的信心。
**混沌工程**：一门旨在通过故意注入故障等实验来提高对容错机制的信心的学科。

#### 硬件与软件故障

常见的硬件故障：
- 大约 2-5% 的磁性硬盘驱动器每年发生故障
- 大约 0.5-1% 的固态硬盘（SSD）每年发生故障
- 大约千分之一的机器有一个 CPU 核心偶尔计算错误的结果，可能是由于制造缺陷
- RAM 中的数据也可能被损坏，要么是由于宇宙射线等随机事件，要么是由于永久性物理缺陷。即使使用纠错码（ECC）的内存，超过 1% 的机器在给定年份遇到不可纠正的错误
在大规模系统中，硬件故障发生得足够频繁，以至于它们成为正常系统运行的一部分。

##### 通过冗余容忍硬件故障

我们对不可靠硬件的第一反应通常是向各个硬件组件添加冗余，以降低系统的故障率。
- 磁盘可以设置为 RAID 配置（将数据分布在同一台机器的多个磁盘上，以便故障磁盘不会导致数据丢失）
- 服务器可能有双电源和可热插拔的 CPU

硬件冗余增加了单台机器的正常运行时间,使用分布式系统有一些优势，例如能够容忍一个数据中心的完全中断。

**滚动升级**：如果你需要重新启动机器（例如，应用操作系统安全补丁），单服务器系统需要计划停机时间，而多节点容错系统可以一次修补一个节点，而不影响用户的服务。这称为 _滚动升级_

##### 软件故障

硬件故障大多数都是独立的，软件故障通常是高度相关的。这种故障比不相关的硬件故障更难预料，并且它们往往导致比硬件故障更多的系统失效。
- 在特定情况下导致每个节点同时失效的软件错误。
- 使用某些共享、有限资源（如 CPU 时间、内存、磁盘空间、网络带宽或线程）的失控进程
- 系统所依赖的服务变慢、无响应或开始返回损坏的响应。

软件故障的设计方案：仔细考虑系统中的假设和交互；彻底测试；进程隔离；允许进程崩溃和重新启动；避免反馈循环，如重试风暴

#### 人类与可靠性

在日常业务的务实现实中，组织通常优先考虑创收活动而不是增加其抵御错误的韧性的措施。如果在更多功能和更多测试之间有选择，许多组织可以理解地选择功能。鉴于这种选择，当可预防的错误不可避免地发生时，责怪犯错误的人是没有意义的——问题是组织的优先事项。

管理层应该借此机会从每天与之合作的人的角度了解社会技术系统如何工作的细节，并根据这些反馈采取措施改进它

### 可伸缩性

**可伸缩性**：用来描述系统应对负载增加能力的术语

#### 描述负载

包括：吞吐量的度量、某个变量数量的峰值、还有其他影响访问模式并因此影响可伸缩性要求的负载统计特征

目标是在最小化运行系统成本的同时保持系统性能在 SLA 的要求范围内

#### 共享内存、共享磁盘与无共享架构

增加服务硬件资源的最简单方法是将其移动到更强大的机器。
**纵向伸缩**：购买一台机器（或租用云实例）具有更多 CPU 核心、更多 RAM 和更多磁盘空间。
**共享内存架构**：通过使用多个进程或线程在单台机器上获得并行性；成本增长速度快于线性：具有两倍硬件资源的高端机器通常成本远远超过两倍
**共享磁盘架构**：使用几台具有独立 CPU 和 RAM 的机器，但将数据存储在机器之间共享的磁盘阵列上，这些机器通过快速网络连接：_网络附加存储_（NAS）或 _存储区域网络_（SAN）
**无共享架构**（ _横向伸缩_ 或 _向外扩展_）：具有多个节点的分布式系统，每个节点都有自己的 CPU、RAM 和磁盘。节点之间的任何协调都在软件级别通过传统网络完成。
- 优点：有线性伸缩的潜力，它可以使用提供最佳性价比的任何硬件
- 缺点：显式分片，它会产生分布式系统的所有复杂性

#### 可伸缩性原则

可伸缩性的一个良好通用原则是将系统分解为可以在很大程度上相互独立运行的较小组件
另一个好原则是不要让事情变得比必要的更复杂。如果单机数据库可以完成工作，它可能比复杂的分布式设置更可取。

### 可运维性

软件的大部分成本不在其初始开发中，而在其持续维护中——修复错误、保持其系统运行、调查故障、将其适应新平台、为新用例修改它、偿还技术债务和添加新功能

几个广泛适用的原则：
- **可运维性（Operability）**：使组织容易保持系统平稳运行
- **简单性（Simplicity）**：通过使用易于理解、一致的模式和结构来实施它，并避免不必要的复杂性，使新工程师容易理解系统。
- **可演化性（Evolvability）**：使工程师将来容易对系统进行更改，随着需求变化而适应和扩展它以用于未预料的用例。

#### 可运维性：让运维更轻松

运维很重要：良好的运维通常可以解决糟糕（或不完整）软件的局限性，但再好的软件碰上糟糕的运维也难以可靠地运行

良好的可操作性意味着使常规任务变得容易，使运维团队能够将精力集中在高价值活动上。 数据系统可以做各种事情来使常规任务变得容易，包括：
- 允许监控工具检查系统的关键指标，并支持可观测性工具
- 避免对单个机器的依赖（允许在系统整体继续不间断运行的同时关闭机器进行维护）
- 提供良好的文档和易于理解的操作模型

#### 简单性：管理复杂度

推理复杂性的一种尝试是将其分为两类，**本质复杂性** 和 **偶然复杂性**：
- 本质复杂性是应用程序问题域中固有的
- 偶然复杂性仅由于我们工具的限制而产生
管理复杂性的最佳工具之一是 **抽象**。良好的抽象可以在干净、易于理解的外观后面隐藏大量实现细节。良好的抽象也可以用于各种不同的应用程序。

#### 可演化性：让变化更容易

在组织流程方面，_敏捷_ 工作模式为适应变化提供了框架。敏捷社区还开发了在频繁变化的环境中开发软件时有用的技术工具和流程， 例如测试驱动开发（TDD）和重构。

## 3. 数据模型与查询语言

**数据模型**不仅影响软件的编写方式，还影响我们 **思考问题** 的方式。

如何用更低层次的数据模型来 **表示**应用程序：
- 观察现实世界并用对象或数据结构，以及操作这些数据结构的 API 来建模。这些结构通常是特定于应用程序的。
- 用通用的数据模型来表达它们，例如 JSON 或 XML 文档、关系数据库中的表，或者图中的顶点和边
- 用内存、磁盘或网络上的字节来表示文档/关系/图数据

**基本思想**：每一层通过提供一个简洁的数据模型来隐藏下层的复杂性。

在本章中，通过比较关系模型、文档模型、基于图的数据模型、事件溯源和数据框来探讨这些权衡。

### 关系模型与文档模型

 1970 年Edgar Codd提出最早的的关系模型：SQL，数据被组织成 **关系**（在 SQL 中称为 **表**），其中每个关系是 **元组**（在 SQL 中称为 **行**）的无序集合。
 20 世纪 80 年代中期，关系数据库管理系统（RDBMS）和 SQL 已成为大多数需要存储和查询具有某种规则结构的数据的人的首选工具。 
 20 世纪 70 年代和 80 年代初，**网状模型** 和 **层次模型** 是主要的替代方案，但关系模型最终战胜了它们。
  2010 年代，**NoSQL** 是试图推翻关系数据库主导地位的最新流行词。一些数据库将自己标榜为 _NewSQL_，因为它们旨在提供 NoSQL 系统的可伸缩性以及传统关系数据库的数据模型和事务保证。 NoSQL 和 NewSQL 的想法在数据系统设计中产生了很大的影响，但随着这些原则被广泛采用，这些术语的使用已经减少。
  NoSQL 运动的一个持久影响是 **文档模型** 的流行，它通常将数据表示为 JSON。 这个模型最初由专门的文档数据库（如 MongoDB 和 Couchbase）推广，尽管大多数关系数据库现在也增加了 JSON 支持。
#### 对象关系不匹配

大部分应用程序开发都是使用面向对象的编程语言完成的。如果数据存储在关系表中，则需要在应用程序代码中的对象和数据库的表、行、列模型之间建立一个笨拙的转换层。这种模型之间的脱节有时被称为 **阻抗不匹配**。

##### 对象关系映射（ORM）

对象关系映射（ORM）框架（如 ActiveRecord 和 Hibernate）减少了这个转换层所需的样板代码量，但它们经常受到批评，有如下问题：
- ORM 很复杂，无法完全隐藏两种模型之间的差异
- ORM 通常仅用于 OLTP 应用程序开发，为分析目的提供数据的数据工程师仍然需要使用底层的关系表示
- 许多 ORM 仅适用于关系型 OLTP 数据库
- 一些 ORM 会自动生成关系模式，但这些模式对于直接访问关系数据的用户来说可能很尴尬
- ORM 使得意外编写低效查询变得容易，例如 _N+1 查询问题_
ORM的优势：
- 对于非常适合关系模型的数据，ORM 减少了这种转换所需的样板代码量
- ORM 有助于缓存数据库查询的结果，这可以帮助减少数据库的负载
- ORM 还可以帮助管理模式迁移和其他管理活动

##### 用于一对多关系的文档数据模型

**一对多关系**的关系化表达
![[file-20250812214919026.png]]
JSON 模型能减少应用程序代码和存储层之间的阻抗不匹配，但是JSON 作为数据编码格式也存在问题。JSON 表示具有更好的 _局部性_，所有相关信息都在一个地方，使查询既更快又更简单。
![[file-20250812215109300.png]]

#### 规范化、反规范化与连接

使用 ID，数据更加规范化：对人类有意义的信息只存储在一个地方，所有引用它的地方都使用 ID。当你直接存储文本时，你在使用它的每条记录中都复制了对人类有意义的信息；这种表示是 _反规范化_ 的。

规范化表示的缺点是，每次要显示包含 ID 的记录时，都必须进行额外的查找以将 ID 解析为人类可读的内容。

文档数据库可以存储规范化和反规范化的数据，但它们通常与反规范化相关联 —— 部分是因为 JSON 数据模型使得存储额外的反规范化字段变得容易，部分是因为许多文档数据库中对连接的弱支持使得规范化不方便。

##### 规范化的权衡
作为一般原则，规范化数据通常写入更快（因为只有一个副本），但查询更慢（因为它需要连接）；反规范化数据通常读取更快（连接更少），但写入更昂贵（更多副本要更新，使用更多磁盘空间）

规范化往往更适合 OLTP 系统，其中读取和更新都需要快速；分析系统通常使用反规范化数据表现更好，因为它们批量执行更新，只读查询的性能是主要关注点

在中小规模的系统中，规范化数据模型通常是最好的，因为你不必担心保持数据的多个副本相互一致，执行连接的成本是可以接受的。然而，在非常大规模的系统中，连接的成本可能会成为问题。
##### 社交网络案例研究中的反规范化

