作者： Martin Kleppmann                        
阅读日期：20250811——20250830
学习网站：http://ddia.vonng.com/

# 目录

第一部分：数据系统基础——设计数据密集型应用所赖的基本思想
1. 数据系统架构中的权衡 
2. 定义非功能性需求 
3. 数据模型与查询语言 
4. 存储与检索 
5. 编码与演化
第二部分：分布式数据——存储在一台机器上的数据转向讨论分布在多台机器上的数据
6. 复制 
7. 分片 
8. 事务 
9. 分布式系统的麻烦 
10.  一致性与共识 
第三部分：派生数据——从其他数据集派生出一些数据集的系统。
11. 批处理 
12. 流处理 
13. 数据系统的未来 

# 序言

**数据密集型应用（data-intensive applications）** 正在通过使用这些技术进步来推动可能性的边界。一个应用被称为 **数据密集型** 的，如果 **数据是其主要挑战**（数据量，数据复杂度或数据变化速度）—— 与之相对的是 **计算密集型**，即处理器速度是其瓶颈。

# 第一部分：数据系统基础

## 1、数据系统架构中的权衡 

如果数据管理是开发应用程序的主要挑战之一，我们就称应用程序为 **数据密集型（data-intensive）** 的，关心诸如**存储和处理大量数据、管理数据变更、在面对故障和并发时确保一致性，以及确保服务高可用**等问题。一般需要通过**数据库、缓存、索引、流批处理**来构建。

### 分析型与事务型系统

三类人：
- **后端工程师**：构建处理读取和更新数据请求的服务；这些服务通常直接或间接地通过其他服务为外部用户提供服务
- **业务分析师**：生成关于组织活动的报告，以帮助管理层做出更好的决策
- **数据科学家**：在数据中寻找新的见解，或创建由数据分析和机器学习/AI 支持的面向用户的产品功能

业务分析师和数据科学家两者都执行 **分析**，这意味着他们查看用户和后端服务生成的数据，但他们通常不修改这些数据，这导致了两种类型系统之间的分离：
- **事务型系统** 由后端服务和数据基础设施组成，在这里创建数据，例如通过服务外部用户。在这里，应用程序代码基于用户执行的操作读取和修改其数据库中的数据。
- **分析型系统** 服务于业务分析师和数据科学家的需求。它们包含来自事务型系统的只读数据副本，并针对分析所需的数据处理类型进行了优化。

随着这些系统的成熟，出现了两个新的专业角色：**数据工程师** 和 **分析工程师**。
- **数据工程师**是知道如何集成事务型系统和分析型系统的人，并更广泛地负责组织的数据基础设施
- **分析工程师**对数据进行建模和转换，使其对组织中的业务分析师和数据科学家更有用

#### 事务处理与分析的特征

- **OLTP**：事务型系统通常通过某个键查找少量记录（这称为 **点查询**）。基于用户的输入插入、更新或删除记录。因为这些应用程序是交互式的，这种访问模式被称为 **联机事务处理**（OLTP）
- **OLAP**：分析具有非常不同的访问模式。通常，分析查询会扫描大量记录，并计算聚合统计信息（如计数、求和或平均值），而不是将单个记录返回给用户，被称为 **联机分析处理**（OLAP）

|属性|事务型系统（OLTP）|分析型系统（OLAP）|
|---|---|---|
|主要读取模式|点查询（通过键获取单个记录）|对大量记录进行聚合|
|主要写入模式|创建、更新和删除单个记录|批量导入（ETL）或事件流|
|人类用户示例|Web/移动应用程序的最终用户|内部分析师，用于决策支持|
|机器使用示例|检查操作是否被授权|检测欺诈/滥用模式|
|查询类型|固定的查询集，由应用程序预定义|分析师可以进行任意查询|
|数据代表|数据的最新状态（当前时间点）|随时间发生的事件历史|
|数据集大小|GB 到 TB|TB 到 PB|
#### 数据仓库

90 年代初，公司倾向于停止使用其 OLTP 系统进行分析目的，而是在单独的数据库系统上运行分析。这个单独的数据库被称为 **数据仓库**。有以下几个原因：
- 数据孤岛问题
- 查询模式和数据布局不太合适
- 分析查询相当昂贵

数据仓库包含公司中所有各种 OLTP 系统中数据的只读副本。数据从 OLTP 数据库中提取（使用定期数据转储或连续更新流），转换为分析友好的模式，清理，然后加载到数据仓库中。这种将数据导入数据仓库的过程称为 **提取-转换-加载**（ETL）
![[file-20250811204322471.png]]
一些数据库系统提供 **混合事务/分析处理**（HTAP），旨在在单个系统中启用 OLTP 和分析，而无需从一个系统 ETL 到另一个系统。**HTAP 不会取代数据仓库**。相反，它在同一应用程序需要既执行扫描大量行的分析查询，又以低延迟读取和更新单个记录的场景中很有用。

##### 从数据仓库到数据湖

**数据分析师**：使用通过 SQL 查询的 **关系** 数据模型
**数据科学家**：将数据转换为适合训练机器学习模型的形式（特征工程）；使用自然语言处理技术尝试从中提取结构化信息。


数据科学家不喜欢在数据仓库等关系数据库中工作，更喜欢使用 Python 数据分析库（如 pandas 和 scikit-learn）、统计分析语言（如 R）和分布式分析框架。

组织面临着以适合数据科学家使用的形式提供数据的需求。通过数据湖解决：

**数据湖**：一个集中的数据存储库，保存任何可能对分析有用的数据副本，通过 ETL 过程从事务型系统获得。与数据仓库的区别在于，数据湖只是包含文件，而不强制任何特定的文件格式或数据模型。数据湖中的文件可能是数据库记录的集合，使用 Avro 或 Parquet 等文件格式编码，但它们同样可以包含文本、图像、视频、传感器读数、稀疏矩阵、特征向量、基因组序列或任何其他类型的数据 [15](http://ddia.vonng.com/ch1/#fn:15)。除了更灵活之外，这通常也比关系数据存储更便宜，因为数据湖可以使用商品化的文件存储，如对象存储

ETL 过程已经泛化为 **数据管道**

从数据湖加载数据到单独的数据仓库之外，还可以直接在数据湖中的文件上运行典型的数据仓库工作负载（SQL 查询和业务分析），以及数据科学/机器学习工作负载。这种架构被称为 **数据湖仓**，它需要一个查询执行引擎和一个元数据（例如，模式管理）层来扩展数据湖的文件存储。
**数据湖仓**：数据湖上的仓，是湖也是仓

##### 超越数据湖

在某些情况下，分析系统的输出被提供给事务型系统（这个过程有时被称为 **反向 ETL**）

例如，在分析系统中训练的机器学习模型可能会部署到生产环境中，以便为最终用户生成推荐，例如"购买了 X 的人也购买了 Y"。这种分析系统的部署输出也被称为 **数据产品**

#### 权威数据源与派生数据

**权威记录系统**：权威记录系统，也称为 权威数据源，保存某些数据的权威或 规范 版本。当新数据进入时，例如作为用户输入，它首先写入这里。每个事实只表示一次。如果另一个系统与权威记录系统之间存在任何差异，那么权威记录系统中的值（根据定义）是正确的。

**派生数据系统**：派生系统中的数据是从另一个系统获取一些现有数据并以某种方式转换或处理它的结果。如果你丢失了派生数据，你可以从原始源重新创建它。一个经典的例子是缓存：如果存在，可以从缓存提供数据，但如果缓存不包含你需要的内容，你可以回退到底层数据库。反规范化值、索引、物化视图、转换的数据表示和在数据集上训练的模型也属于这一类别。

- 分析系统通常是派生数据系统，因为它们是在其他地方创建的数据的消费者。
- 事务型服务可能包含权威记录系统和派生数据系统的混合。

### 云服务与自托管

公认的管理智慧是，作为组织核心竞争力或竞争优势的事物应该在内部完成，而非核心、例行或常见的事物应该留给供应商。
 **自托管** 的现成软件（开源或商业），即自己部署

#### 云服务的利弊

云服务的最大缺点是你无法控制它：
- 功能定制开发
- 服务宕机等恢复
- 出错难以诊断
- 存在数据安全问题

#### 云原生系统架构

从头开始设计为云原生的系统已被证明具有几个优势：在相同硬件上具有更好的性能、从故障中更快恢复、 能够快速扩展计算资源以匹配负载，以及支持更大的数据集

| 类别       | 自托管系统                     | 云原生系统                                                     |
| -------- | ------------------------- | --------------------------------------------------------- |
| 事务型/OLTP | MySQL、PostgreSQL、MongoDB  | AWS Aurora 、Azure SQL DB Hyperscale 、Google Cloud Spanner |
| 分析型/OLAP | Teradata、ClickHouse、Spark | Snowflake、Google BigQuery、Azure Synapse Analytics         |
###### 云服务的分层

- 自托管软件倾向于使用非常通用的计算资源：CPU、RAM、文件系统和 IP 网络。
- 云实例可以更快地配置，并且有更多种类的大小，但除此之外，它们与传统计算机类似

云原生服务的关键思想是不仅使用由操作系统管理的计算资源，还基于较低级别的云服务构建更高级别的服务。例如：
- **对象存储** 服务存储大文件，隐藏了底层物理机器，不必担心任何一台机器上的磁盘空间用完，也不会丢失数据。
- 许多其他服务反过来建立在对象存储和其他云服务之上：例如，Snowflake 是一个基于云的分析数据库（数据仓库），依赖于 S3 进行数据存储

###### 存储和计算的分离

**传统计算**：磁盘存储被认为是持久的，为了容忍单个硬盘的故障，通常使用 RAID（独立磁盘冗余阵列）在连接到同一台机器的几个磁盘上维护数据副本。它对访问文件系统的应用程序是透明的。
**云计算**：云原生系统通常将这些磁盘更多地视为临时缓存，而不是长期存储。如果实例被替换，本地磁盘会不可访问

云服务还提供可以从一个实例分离并附加到另一个实例的虚拟磁盘存储，种虚拟磁盘实际上不是物理磁盘，而是由一组单独的机器提供的云服务，它模拟磁盘的行为。但是对网络很敏感。

云原生服务通常避免使用虚拟磁盘，而是建立在针对特定工作负载优化的专用存储服务之上。对象存储服务（如 S3）设计用于长期存储相当大的文件，大小从数百千字节到几千兆字节不等。数据库中存储的单个行或值通常比这小得多；
**云数据库通常在单独的服务中管理较小的值，并将较大的数据块（包含许多单个值）存储在对象存储中**

云原生系统中，存储（磁盘）和计算（CPU 和 RAM）在某种程度上分离或 **解耦**。

#### 云时代的运维

**运维**：确保服务可靠地交付给用户（包括配置基础设施和部署应用程序），并确保稳定的生产环境（包括监控和诊断可能影响可靠性的任何问题）

从单个机器到服务的重点转移伴随着运维角色的变化。提供可靠服务的高级目标保持不变，但流程和工具已经发展。DevOps/SRE 理念更加强调：自动化、频繁更新等等。

云正在改变运维的角色，但对运维的需求比以往任何时候都大。

### 分布式与单节点系统

涉及多台机器通过网络通信的系统称为 **分布式系统**。参与分布式系统的每个进程称为 **节点**。做分布式有很多原因，如：高可用、可伸缩、低延迟、弹性、可持续性等等

#### 分布式系统的问题

- 网络传输中断、响应时间慢、分布式事务等等

#### 微服务与 Serverless

分布系统的最常见方式是：分为客户端和服务器，并让客户端向服务器发出请求。最常见的是使用 HTTP 进行此通信。

这种构建应用程序的方式传统上被称为 **面向服务架构**（SOA），目前被细化为**微服务** 架构。

微服务架构的特点：服务有一个明确定义的目的；每个服务公开一个可以由客户端通过网络调用的 API，每个服务有一个负责其维护的团队。

带来的复杂性：每个服务都需要用于部署新版本、调整分配的硬件资源以匹配负载、收集日志、监控服务健康状况以及在出现问题时向值班工程师发出警报的基础设施。

#### 云计算与超级计算

云计算不是构建大规模计算系统的唯一方式；另一种选择是 **高性能计算**（HPC），也称为 **超级计算**。HPC 通常有不同的优先级并使用不同的技术：
- HPC 通常有不同的优先级并使用不同的技术。
- 通常运行大型批处理作业，定期将其计算状态检查点到磁盘。
- 通常通过共享内存和远程直接内存访问（RDMA）进行通信，这支持高带宽和低延迟

### 数据系统、法律与社会

**通用数据保护条例**（GDPR）：多欧洲国家居民对其个人数据更大的控制权和法律权利，类似的隐私法规已在世界各地的各个国家和州采用，包括例如加州消费者隐私法（CCPA）。关于 AI 的法规，例如 **欧盟 AI 法案**，对个人数据的使用方式施加了进一步的限制。

## 2. 定义非功能性需求

应用程序的非功能需求，比如应用程序应该快速、可靠、安全、合规，并且易于维护

从一个案例研究开始本章，研究社交网络服务可能如何工作，这将提供性能和可伸缩性的实际案例。

### 案例研究：社交网络首页时间线

社交网络服务：假设用户每天发布 5 亿条帖子，或平均每秒 5,700 条帖子。偶尔，速率可能飙升至每秒 150,000 条帖子。

![[file-20250812104503252.png]]
帖子应该是及时的，所以假设在某人发布帖子后，我们希望他们的粉丝能够在 5 秒内看到它。一种方法是让用户的客户端每 5 秒重复上述查询（这称为 _轮询_）。如果我们假设有 1000 万用户同时在线登录，这意味着每秒运行 200 万次查询。即使增加轮询间隔，这也是很大的负载。

#### 时间线的物化与更新

每次用户发布帖子时，我们查找他们的所有粉丝，并将该帖子插入到每个粉丝的首页时间线中——就像向邮箱投递消息一样。现在当用户登录时，我们可以简单地给他们这个预先计算的首页时间线。此外，要接收时间线上任何新帖子的通知，用户的客户端只需订阅添加到其首页时间线的帖子流。
![[file-20250812104720007.png]]这种预先计算和更新查询结果的过程称为 **物化**，时间线缓存是 _物化视图_ 的一个例子

### 描述性能

考虑两种主要的度量类型：
- **响应时间**：从用户发出请求到收到所请求答案的经过时间。
- **吞吐量**：系统正在处理的每秒请求数，或每秒数据量。

随着服务的吞吐量接近其容量，由于排队，响应时间急剧增加。
![[file-20250812105314815.png]]

就性能指标而言，响应时间通常是用户最关心的，而吞吐量决定了所需的计算资源，因此决定了服务特定工作负载的成本。
如果系统的最大吞吐量可以通过添加计算资源显著增加，则称系统为 _可伸缩的_。

#### 延迟与响应时间

- _响应时间_ 是客户端看到的；它包括系统中任何地方产生的所有延迟。
- _服务时间_ 是服务主动处理用户请求的持续时间。
- _排队延迟_ 可能发生在流程中的几个点：例如，在收到请求后，它可能需要等待直到 CPU 可用才能被处理；如果同一台机器上的其他任务通过出站网络接口发送大量数据，响应数据包可能需要在发送之前进行缓冲。
- _延迟_ 是一个涵盖请求未被主动处理时间的总称，即在此期间它是 _潜在的_。特别是，_网络延迟_ 或 _网络延迟_ 指的是请求和响应在网络中传输所花费的时间。
![[file-20250812110210600.png]]
#### 平均值、中位数与百分位数

因为响应时间因请求而异，我们需要将其视为值的 _分布_，而不是单个数字。
**平均响应时间**：对于估计吞吐量限制很有用
**中位数**：如果你将响应时间列表从最快到最慢排序，那么 _中位数_ 就在中间中位数成为了解用户通常需要等待多长时间的良好指标。中位数也称为 _第 50 百分位_，有时缩写为 _p50_。
**百分位数**：为了弄清异常值有多糟糕，_第 95_、_99_ 和 _99.9_ 百分位数很常见，它们是 95%、99% 或 99.9% 的请求比该特定阈值快的响应时间阈值。

响应时间的高百分位数，也称为 _尾部延迟_，很重要，因为它们直接影响用户的服务体验。

#### 响应时间指标的应用

高百分位数在被多次调用作为服务单个最终用户请求的一部分的后端服务中尤其重要。

百分位数通常用于 _服务级别目标_（SLO）和 _服务级别协议_（SLA），作为定义服务预期性能和可用性的方式

### 可靠性与容错

可靠性：即使出现问题也能继续正确工作。
为了更准确地说明出现问题，我们将区分 故障 和 失效：
- **故障**：故障是指系统的某个特定 _部分_ 停止正确工作：例如，如果单个硬盘驱动器发生故障，或单台机器崩溃，或外部服务（系统所依赖的）发生中断。
- **失效**：失效是指 _整个_ 系统停止向用户提供所需的服务；换句话说，当它不满足服务级别目标（SLO）时。

故障和失效之间的区别可能会令人困惑，因为它们在不同层面上是同一件事。
#### 容错

**容错**：如果系统在发生某些故障时仍继续向用户提供所需的服务，我们称系统为 _容错的_。
**单点故障**：如果系统不能容忍某个部分变得有故障，我们称该部分为 _单点故障_（SPOF），因为该部分的故障会升级导致整个系统的失效。
**故障注入**：在这种容错系统中，通过故意触发故障来 _增加_ 故障率是有意义。通过故意引发故障，你确保容错机制不断得到锻炼和测试，这可以增加你对故障自然发生时将被正确处理的信心。
**混沌工程**：一门旨在通过故意注入故障等实验来提高对容错机制的信心的学科。

#### 硬件与软件故障

常见的硬件故障：
- 大约 2-5% 的磁性硬盘驱动器每年发生故障
- 大约 0.5-1% 的固态硬盘（SSD）每年发生故障
- 大约千分之一的机器有一个 CPU 核心偶尔计算错误的结果，可能是由于制造缺陷
- RAM 中的数据也可能被损坏，要么是由于宇宙射线等随机事件，要么是由于永久性物理缺陷。即使使用纠错码（ECC）的内存，超过 1% 的机器在给定年份遇到不可纠正的错误
在大规模系统中，硬件故障发生得足够频繁，以至于它们成为正常系统运行的一部分。

##### 通过冗余容忍硬件故障

我们对不可靠硬件的第一反应通常是向各个硬件组件添加冗余，以降低系统的故障率。
- 磁盘可以设置为 RAID 配置（将数据分布在同一台机器的多个磁盘上，以便故障磁盘不会导致数据丢失）
- 服务器可能有双电源和可热插拔的 CPU

硬件冗余增加了单台机器的正常运行时间,使用分布式系统有一些优势，例如能够容忍一个数据中心的完全中断。

**滚动升级**：如果你需要重新启动机器（例如，应用操作系统安全补丁），单服务器系统需要计划停机时间，而多节点容错系统可以一次修补一个节点，而不影响用户的服务。这称为 _滚动升级_

##### 软件故障

硬件故障大多数都是独立的，软件故障通常是高度相关的。这种故障比不相关的硬件故障更难预料，并且它们往往导致比硬件故障更多的系统失效。
- 在特定情况下导致每个节点同时失效的软件错误。
- 使用某些共享、有限资源（如 CPU 时间、内存、磁盘空间、网络带宽或线程）的失控进程
- 系统所依赖的服务变慢、无响应或开始返回损坏的响应。

软件故障的设计方案：仔细考虑系统中的假设和交互；彻底测试；进程隔离；允许进程崩溃和重新启动；避免反馈循环，如重试风暴

#### 人类与可靠性

在日常业务的务实现实中，组织通常优先考虑创收活动而不是增加其抵御错误的韧性的措施。如果在更多功能和更多测试之间有选择，许多组织可以理解地选择功能。鉴于这种选择，当可预防的错误不可避免地发生时，责怪犯错误的人是没有意义的——问题是组织的优先事项。

管理层应该借此机会从每天与之合作的人的角度了解社会技术系统如何工作的细节，并根据这些反馈采取措施改进它

### 可伸缩性

