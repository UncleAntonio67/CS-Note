## 计算机网络

OSI开放式互联参考模型
物理层：物理设备标准、传输比特流（网卡）
数据链路层：数据帧（交换机）
网络层：网络间传输、数据包（路由器）
传输层：数据间的传输质量，流量控制，TCP/UDP
会话层：建立管理应用程序的通讯
表示层：不同系统的会话问题
应用层：应用层的网络协议 HTTP协议

TCP/IP 4层模型
链路层（数据链路层、物理层）
网络层
传输层
应用层（应用层、表示层、会话层）

### 说说TCP的三次握手
TCP
面向连接的、可靠的、基于字节流的传输层通信协议
将应用层的数据流分割成报文段并发送给目标节点的TCP层
数据包都有序号，对方收到则发送ACK确认，未收到则重传
使用校验和来检验数据在传输过程中是否有误

源端口、目的端口、序列号、ACK、Offset、窗口、校验和、保留域
常见标志位：
URG：紧急指针标志
ACK：确认序号标志
PSH：push编制
Syn：同步序号，用于建立连接
FIN：完成标志，用于释放连接
![[Pasted image 20250607123944.png]]第一次：发Syn包
第二次：确认Syn，自己也发一个Syn
第三次：收到SYN、ACK，发从ACK
为什么需要三次握手才能建立联系
为了初始化Seq的初始值

首次握手的隐患——SYN超时
linux会重试5次，大概63s才会断开连接
针对SYN Flood的防护参数
SYN满了之后，通过tcp_syncookies会发SYN cookie
若为正常连接则Client会回发Syn Cookie，直接建立连接

保活机制

### TCP的四次挥手
![[Pasted image 20250607125925.png]]
第一次挥手：发一个FIN
第二次挥手：收到后，发一个ACK，确认序号为seq+1，进入CLosewait状态
第三次挥手：Server发一个Fin，Server进入Last ACK状态
第四次挥手：CLient收到Fin后，进入TIME Wait状态，发送一个ACK给Server，Server进入Closed状态

为什么会有TIME_WAIT状态
确保有足够的时候让对方收到ACK包
避免新旧连接混淆
为什么需要四次挥手才能断开连接
因为全双工，发送方和接受方都需要FIN、ACK

服务器出现大量的Close Wait状态的原因
对方关闭socket连接，我方忙于读或写，没有及时关闭连接
检查代码、检查配置


### UDP简介
面向非连接
不维护连接状态，支持同时向多个客户端传输相同的消息
数据包只有8歌个字节
吞吐量受限于生成速率等

对比：
面向连接 vs 无连接
可靠性
有序性
速度
量级



### TCP的滑动窗口

RTT：发送一个数据包到收回对应的ACK，所花费的时间
RTO：重传时间间隔

TCP使用滑动窗口做流量控制和乱序重排，保证它的可靠性和流控特性


### HTTP协议
超文本传输协议：
支持客户服务器模式
简单快速
灵活
无连接
无状态

请求报文、响应报文

键入URL后，经历的流程
DNS解析/TCP连接/发送HTTP请求/处理请求返回报文/解析页面/连接结束

HTTP状态码
1xx 已接受，继续处理
200正常/
2xx 重定向
404 客户端错误 资源不在，400请求有语法错误，403拒绝服务
500 服务端错误
503 当前不能处理请求
 Get请求和POST的区别
HTTP报文层面：get请求信息放在URL，post在报文体里
数据库层面：GET符合幂等和安全（查询操作），POST不安全（会提交数据）
其他层面：GET可以被缓存、被存储，而POST不行

Cookie和Session的区别
Cookie：服务器发给客户端的特殊信息，以文本的形式存放在客户端
客户端再次请求是，会把Cookie回发
Session：服务器端的机制，再服务器上保存的信息，解析客户端请求并处理session id，按需保存状态信息，可以使用Cookie实现/使用url回写
Session更加安全，但可能影响性能

HTTP和HTTPS的区别

加入了SSL or TLS层
SSL（安全套接层）3.0被称为TLS
采用身份验证和数据加密保证网络通信的安全和数据的完整性

加密的方式：
对称：加密解密使用同一个密钥
非对称：密钥不同
哈希算法
数字签名

 HTTPS数据传输流程：
 浏览器加支持的算法发给服务器；
 服务选一套算法，以证书回发给浏览器
 浏览器验证证书合法性，结合公钥加密发给服务器
 服务器使用私钥解析，验证哈希
 浏览器解析响应消息
HTTPS需要到申请CA证书
HTTPS密文传输
联系方式不同，HTTPS 443端口

HTTPS= HTTP+加密+认证+完整性


浏览器默认http，可以使用HST优化


### Socket简介
Socket是TCP/IP的抽象，是操作系统对外开放的接口
Socket通信流程
![[Pasted image 20250607134147.png]]


## 数据库


关系型数据库（架构、索引、锁、语法、理论范式）
如何设计一个关系型数据库
存储模块、程序实例（存储管理、缓存机制、SQL解析、日志管理、权限划分、容灾机制、索引、锁）
### 索引模块
为什么用索引
快速查询数据
什么样可以是索引
主键、唯一键、普通键
索引的数据结构
生成索引，二叉树、B+、B-、Hash
 二叉查找树上阵
 O(logn) 
 1、时间复杂度可能会提高 O(n)
 2、两个节点，树可能很高
B-Tree平衡多路查找树
定义：根节点至少有两个孩子
树中每个节点最多有m个孩子（m>=2）
除根节点和叶节点外，其他每个节点至少有ceil（m/2）个孩子
所有叶子节点都位于同一层
还有一个关键信息
![[Pasted image 20250607200533.png]]

树会变矮，不会成为线性

B+-Tree平衡多路查找树
定义与B树类似，除了：

![[Pasted image 20250607200958.png]]
![[Pasted image 20250607200942.png]]

B+ 更适合用来做存储索引
1、读写代价更低
2、查询效率更加稳定
3、更有利于对数据库的扫描

Hash索引也可以考虑以下
![[Pasted image 20250607201218.png]]
效率很高，但有缺点：
不能进行范围查询
无法被用来避免数据的排序操作
不能利用部分索引查询
不能避免表扫描
遇到大量Hash相等的情况性能不一定比B树高

BitMap索引
很少支持，结构类似于B+树，不适合高并发

密集索引和稀疏索引？
![[Pasted image 20250607201707.png]]
![[Pasted image 20250607201734.png]]


 MyISAM：稀疏索引
 InnoDB：密集索引
 ![[Pasted image 20250607201851.png]]
 

如何定位并优化慢查询SQL
![[Pasted image 20250607202537.png]]
联合索引的最左匹配原则的成因

一直向右匹配，知道遇到 > < between like这样的就停止匹配，等于的顺序可以乱序，因为mysql会进行优化。按照字段逐个排序

索引是建立得越来越好吗
- 数据量小的表不需要建立索引，会有额外开销
- 数据变更需要维护索引，有更多的维护成本
- 更多的索引也意味着更多的空间

### 锁模块

MyISAM和InnoDB在锁方面的区别是什么？

MyISAM是表级锁，不支持行级锁
InnoDB是行级锁，也支持表级锁

读锁——共享锁
写锁——排他锁

innodb不走索引的时候整张表就会被锁住，走索引才是行级锁

![[file-20250622134139306.png]]
![[file-20250622134206654.png]]

![[file-20250622134303188.png]]

数据库事务的四大特性，ACID

脏读：读到未提交的数据
不可重复读：多次读到的数据不一样
幻读：读到了没见过的数据，插入操作
![[file-20250622151211284.png]]

InnoDB可重复读隔离级别下如何实现避免幻读

![[file-20250622152303503.png]]

![[file-20250622152427760.png]]![[file-20250622152435383.png]]

## Redis

![[file-20250624215706781.png]]

![[file-20250624215736074.png]]


![[file-20250624215750833.png]]

10w QPS
- 完全基于内存，纯粹的内存操作，执行效率高
- 数据结构简单
- 单线程，能处理高并发
- 多路IO复用模型，非阻塞IO


![[file-20250624220210313.png]]

Redis的数据类型
![[file-20250624224823463.png]]

如何从海量key中查询固定前缀的key

![[file-20250624225259856.png]]
![[file-20250624225509767.png]]

如何通过Redis实现分布式锁
解决互斥性、安全性、死锁、容错性的问题
![[file-20250624225835785.png]]

![[file-20250624230017809.png]]

![[file-20250625205509814.png]]

![[file-20250625205616252.png]]

![[file-20250625205645775.png]]

消息发布无状态，无法保证可达

Redis如何做持久和
![[file-20250625210059433.png]]![[file-20250625210304655.png]]

![[file-20250625210421684.png]]![[file-20250625210548743.png]]

AOF持久化，保存写状态
- 记录查询以外的指令
- append追加到AOF
日志重写解决文件会不断变大，原理：
![[file-20250625210937122.png]]

![[file-20250625211039662.png]]
![[file-20250625211156825.png]]
![[file-20250625211320630.png]]


Redis 的主从同步过程

![[file-20250625211520796.png]]


![[file-20250625213233103.png]]


![[file-20250625213344249.png]]

![[file-20250625213434462.png]]


![[file-20250625213549619.png]]一致性哈希

![[file-20250625213735373.png]]


![[file-20250625213844592.png]]

引入虚拟节点

![[file-20250625213918097.png]]



## JVM

Compile Once，Run Anywhere如何实现：

![[1751465589386.png]]

JVM如何加载.class文件

![[1751465887848.png]]


谈谈反射
![[1751465980543.png]]

常用的反馈函数：
Class.forName

类从编译到执行的过程
![[1751466975191.png]]![[1751467621253.png]]

类加载器的双亲委派机制

![[file-20250703205429747.png]]

![[file-20250703210009484.png]]

类的加载方式
- 隐式加载：new
- 显示加载：loadClass、forName
显示加载两种方式的区别：
![[file-20250703210227720.png]]

![[file-20250703210326967.png]]

Java的内存模型
![[file-20250703210822160.png]]
![[file-20250703210934595.png]]
![[file-20250703211002249.png]]
![[file-20250703211030197.png]]


![[file-20250703211456135.png]]

![[file-20250703211538414.png]]

![[file-20250703211737647.png]]


![[file-20250703211819474.png]]

![[file-20250703211945387.png]]

![[file-20250703212047411.png]]


![[file-20250703212146099.png]]

![[file-20250703212232530.png]]
![[file-20250703212345342.png]]

![[file-20250703212603306.png]]



